<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChessBot - Xadrez Inteligente</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f5f0;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 25px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            margin: 0 auto;
            border: 3px solid #2c3e50;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .square {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 50px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .square:hover {
            transform: scale(1.05);
            z-index: 2;
        }
        .white {
            background-color: #f0d9b5;
        }
        .black {
            background-color: #b58863;
        }
        .selected {
            background-color: rgba(46, 204, 113, 0.6);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }
        .possible-move {
            background-color: rgba(52, 152, 219, 0.5);
        }
        .capture-move {
            background-color: rgba(231, 76, 60, 0.5);
            border-radius: 50%;
        }
        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        button {
            padding: 12px 18px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .chat-container {
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 20px;
            background-color: white;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        #chat-output {
            height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            line-height: 1.5;
        }
        #user-input {
            width: 75%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }
        #send-btn {
            width: 20%;
            background-color: #2ecc71;
        }
        .status {
            text-align: center;
            font-weight: bold;
            margin: 15px 0;
            font-size: 1.2em;
            color: #2c3e50;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .tactics-btn {
            background-color: #9b59b6;
        }
        .strategy-btn {
            background-color: #e67e22;
        }
        .full-lesson-btn {
            background-color: #1abc9c;
        }
        .chessbot-msg {
            color: #16a085;
            font-weight: bold;
            margin-bottom: 8px;
            padding: 8px 12px;
            background-color: #e8f8f5;
            border-radius: 8px;
            border-left: 4px solid #1abc9c;
        }
        .user-msg {
            color: #2980b9;
            font-weight: bold;
            margin-bottom: 8px;
            padding: 8px 12px;
            background-color: #ebf5fb;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            text-align: right;
        }
        .move-history {
            max-height: 150px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            margin-top: 15px;
            font-family: monospace;
        }
        @media (max-width: 768px) {
            .chess-board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }
            .square {
                width: 40px;
                height: 40px;
                font-size: 30px;
            }
            button {
                padding: 8px 12px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <h1>ChessBot - Xadrez Inteligente</h1>
    <div class="container">
        <div class="status" id="game-status">Jogo iniciado - Brancas jogam</div>
        <div class="chess-board" id="chess-board"></div>
        <div class="move-history" id="move-history"></div>
        <div class="controls">
            <button id="hint-btn">Dica</button>
            <button id="tactics-btn" class="tactics-btn">Tática</button>
            <button id="strategy-btn" class="strategy-btn">Estratégia</button>
            <button id="full-lesson-btn" class="full-lesson-btn">Aula Completa</button>
            <button id="lesson-btn">Aula Rápida</button>
            <button id="undo-btn">Desfazer</button>
            <button id="reset-btn">Reiniciar</button>
        </div>
        <div class="chat-container">
            <div id="chat-output"></div>
            <div style="display: flex; gap: 10px;">
                <input type="text" id="user-input" placeholder="Pergunte ao ChessBot...">
                <button id="send-btn">Enviar</button>
            </div>
        </div>
    </div>

    <script>
        // Configurações iniciais
        const apiKey = "5XY8QqPYtaJKjL1bZZSR6M8quXETRluO";
        const apiUrl = "https://api.mistral.ai/v1/chat/completions";
        
        // Estado do jogo
        let boardState = initializeBoard();
        let currentPlayer = 'white';
        let selectedPiece = null;
        let possibleMoves = [];
        let gameHistory = [];
        let moveStack = [];
        
        // Elementos do DOM
        const chessBoard = document.getElementById('chess-board');
        const gameStatus = document.getElementById('game-status');
        const chatOutput = document.getElementById('chat-output');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const hintBtn = document.getElementById('hint-btn');
        const tacticsBtn = document.getElementById('tactics-btn');
        const strategyBtn = document.getElementById('strategy-btn');
        const fullLessonBtn = document.getElementById('full-lesson-btn');
        const lessonBtn = document.getElementById('lesson-btn');
        const undoBtn = document.getElementById('undo-btn');
        const resetBtn = document.getElementById('reset-btn');
        const moveHistory = document.getElementById('move-history');
        
        // Inicializa o tabuleiro
        function initializeBoard() {
            // Cria um tabuleiro vazio 8x8
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            // Peças pretas (topo)
            board[0] = ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'];
            for (let i = 0; i < 8; i++) board[1][i] = '♟';
            
            // Peças brancas (base)
            board[7] = ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖'];
            for (let i = 0; i < 8; i++) board[6][i] = '♙';
            
            return board;
        }
        
        // Renderiza o tabuleiro
        function renderBoard() {
            chessBoard.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Marca peça selecionada
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // Marca movimentos possíveis
                    const move = possibleMoves.find(m => m.row === row && m.col === col);
                    if (move) {
                        square.classList.add(move.capture ? 'capture-move' : 'possible-move');
                    }
                    
                    // Adiciona a peça se existir
                    if (boardState[row][col]) {
                        square.textContent = boardState[row][col];
                        
                        // Adiciona classe para peças pretas
                        if (isBlackPiece(boardState[row][col])) {
                            square.style.color = '#000';
                        }
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessBoard.appendChild(square);
                }
            }
            
            // Atualiza histórico de movimentos
            updateMoveHistory();
        }
        
        // Atualiza o histórico de movimentos
        function updateMoveHistory() {
            moveHistory.innerHTML = gameHistory.map((move, index) => 
                `<div>${index + 1}. ${move.move} ${move.capture ? '(captura ' + move.capture + ')' : ''}</div>`
            ).join('');
            moveHistory.scrollTop = moveHistory.scrollHeight;
        }
        
        // Manipula clique no quadrado
        function handleSquareClick(row, col) {
            const piece = boardState[row][col];
            
            // Se não há peça selecionada e o quadrado tem uma peça do jogador atual
            if (!selectedPiece && piece && isCurrentPlayerPiece(piece)) {
                selectedPiece = { row, col };
                possibleMoves = calculatePossibleMoves(row, col);
                renderBoard();
            } 
            // Se há peça selecionada e clicou nela novamente, desseleciona
            else if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                selectedPiece = null;
                possibleMoves = [];
                renderBoard();
            } 
            // Se há peça selecionada e clicou em um movimento possível
            else if (selectedPiece && possibleMoves.some(move => move.row === row && move.col === col)) {
                const move = possibleMoves.find(m => m.row === row && m.col === col);
                movePiece(selectedPiece.row, selectedPiece.col, row, col, move?.special);
                selectedPiece = null;
                possibleMoves = [];
                renderBoard();
                checkGameStatus();
                
                // Se o jogo não terminou, a IA faz seu movimento
                if (!gameStatus.textContent.includes('Xeque-mate') && currentPlayer === 'black') {
                    setTimeout(makeAIMove, 1000);
                }
            }
        }
        
        // Verifica se a peça pertence ao jogador atual
        function isCurrentPlayerPiece(piece) {
            return (currentPlayer === 'white' && isWhitePiece(piece)) || 
                   (currentPlayer === 'black' && isBlackPiece(piece));
        }
        
        // Verifica se a peça é branca
        function isWhitePiece(piece) {
            return ['♙', '♖', '♘', '♗', '♕', '♔'].includes(piece);
        }
        
        // Verifica se a peça é preta
        function isBlackPiece(piece) {
            return ['♟', '♜', '♞', '♝', '♛', '♚'].includes(piece);
        }
        
        // Calcula movimentos possíveis
        function calculatePossibleMoves(row, col) {
            const piece = boardState[row][col];
            const moves = [];
            
            if (!piece) return moves;
            
            // Movimento dos Peões Brancos (♙)
            if (piece === '♙') {
                // Movimento para frente
                if (row < 7 && !boardState[row+1][col]) {
                    moves.push({row: row+1, col});
                    // Primeiro movimento pode avançar 2 casas
                    if (row === 6 && !boardState[row+2][col]) {
                        moves.push({row: row+2, col});
                    }
                }
                // Capturas
                if (row < 7 && col > 0 && boardState[row+1][col-1] && isBlackPiece(boardState[row+1][col-1])) {
                    moves.push({row: row+1, col: col-1, capture: true});
                }
                if (row < 7 && col < 7 && boardState[row+1][col+1] && isBlackPiece(boardState[row+1][col+1])) {
                    moves.push({row: row+1, col: col+1, capture: true});
                }
            } 
            // Movimento dos Peões Pretos (♟)
            else if (piece === '♟') {
                // Movimento para frente
                if (row > 0 && !boardState[row-1][col]) {
                    moves.push({row: row-1, col});
                    // Primeiro movimento pode avançar 2 casas
                    if (row === 1 && !boardState[row-2][col]) {
                        moves.push({row: row-2, col});
                    }
                }
                // Capturas
                if (row > 0 && col > 0 && boardState[row-1][col-1] && isWhitePiece(boardState[row-1][col-1])) {
                    moves.push({row: row-1, col: col-1, capture: true});
                }
                if (row > 0 && col < 7 && boardState[row-1][col+1] && isWhitePiece(boardState[row-1][col+1])) {
                    moves.push({row: row-1, col: col+1, capture: true});
                }
            }
            // Torre (movimentos horizontais/verticais)
            else if (piece === '♖' || piece === '♜') {
                // Movimentos para cima
                for (let r = row-1; r >= 0; r--) {
                    if (!boardState[r][col]) moves.push({row: r, col});
                    else {
                        if ((piece === '♖' && isBlackPiece(boardState[r][col])) || 
                            (piece === '♜' && isWhitePiece(boardState[r][col]))) {
                            moves.push({row: r, col, capture: true});
                        }
                        break;
                    }
                }
                // Movimentos para baixo
                for (let r = row+1; r < 8; r++) {
                    if (!boardState[r][col]) moves.push({row: r, col});
                    else {
                        if ((piece === '♖' && isBlackPiece(boardState[r][col])) || 
                            (piece === '♜' && isWhitePiece(boardState[r][col]))) {
                            moves.push({row: r, col, capture: true});
                        }
                        break;
                    }
                }
                // Movimentos para esquerda
                for (let c = col-1; c >= 0; c--) {
                    if (!boardState[row][c]) moves.push({row, col: c});
                    else {
                        if ((piece === '♖' && isBlackPiece(boardState[row][c])) || 
                            (piece === '♜' && isWhitePiece(boardState[row][c]))) {
                            moves.push({row, col: c, capture: true});
                        }
                        break;
                    }
                }
                // Movimentos para direita
                for (let c = col+1; c < 8; c++) {
                    if (!boardState[row][c]) moves.push({row, col: c});
                    else {
                        if ((piece === '♖' && isBlackPiece(boardState[row][c])) || 
                            (piece === '♜' && isWhitePiece(boardState[row][c]))) {
                            moves.push({row, col: c, capture: true});
                        }
                        break;
                    }
                }
            }
            // Cavalo (movimentos em L)
            else if (piece === '♘' || piece === '♞') {
                const knightMoves = [
                    {row: row-2, col: col-1}, {row: row-2, col: col+1},
                    {row: row-1, col: col-2}, {row: row-1, col: col+2},
                    {row: row+1, col: col-2}, {row: row+1, col: col+2},
                    {row: row+2, col: col-1}, {row: row+2, col: col+1}
                ];
                
                for (const move of knightMoves) {
                    if (move.row >= 0 && move.row < 8 && move.col >= 0 && move.col < 8) {
                        if (!boardState[move.row][move.col] || 
                            (piece === '♘' && isBlackPiece(boardState[move.row][move.col])) || 
                            (piece === '♞' && isWhitePiece(boardState[move.row][move.col]))) {
                            moves.push({
                                row: move.row, 
                                col: move.col, 
                                capture: !!boardState[move.row][move.col]
                            });
                        }
                    }
                }
            }
            // Bispo (movimentos diagonais)
            else if (piece === '♗' || piece === '♝') {
                // Diagonal superior esquerda
                for (let r = row-1, c = col-1; r >= 0 && c >= 0; r--, c--) {
                    if (!boardState[r][c]) moves.push({row: r, col: c});
                    else {
                        if ((piece === '♗' && isBlackPiece(boardState[r][c])) || 
                            (piece === '♝' && isWhitePiece(boardState[r][c]))) {
                            moves.push({row: r, col: c, capture: true});
                        }
                        break;
                    }
                }
                // Diagonal superior direita
                for (let r = row-1, c = col+1; r >= 0 && c < 8; r--, c++) {
                    if (!boardState[r][c]) moves.push({row: r, col: c});
                    else {
                        if ((piece === '♗' && isBlackPiece(boardState[r][c])) || 
                            (piece === '♝' && isWhitePiece(boardState[r][c]))) {
                            moves.push({row: r, col: c, capture: true});
                        }
                        break;
                    }
                }
                // Diagonal inferior esquerda
                for (let r = row+1, c = col-1; r < 8 && c >= 0; r++, c--) {
                    if (!boardState[r][c]) moves.push({row: r, col: c});
                    else {
                        if ((piece === '♗' && isBlackPiece(boardState[r][c])) || 
                            (piece === '♝' && isWhitePiece(boardState[r][c]))) {
                            moves.push({row: r, col: c, capture: true});
                        }
                        break;
                    }
                }
                // Diagonal inferior direita
                for (let r = row+1, c = col+1; r < 8 && c < 8; r++, c++) {
                    if (!boardState[r][c]) moves.push({row: r, col: c});
                    else {
                        if ((piece === '♗' && isBlackPiece(boardState[r][c])) || 
                            (piece === '♝' && isWhitePiece(boardState[r][c]))) {
                            moves.push({row: r, col: c, capture: true});
                        }
                        break;
                    }
                }
            }
            // Rainha (combina torre e bispo)
            else if (piece === '♕' || piece === '♛') {
                // Movimentos de torre
                for (let r = row-1; r >= 0; r--) {
                    if (!boardState[r][col]) moves.push({row: r, col});
                    else {
                        if ((piece === '♕' && isBlackPiece(boardState[r][col])) || 
                            (piece === '♛' && isWhitePiece(boardState[r][col]))) {
                            moves.push({row: r, col, capture: true});
                        }
                        break;
                    }
                }
                for (let r = row+1; r < 8; r++) {
                    if (!boardState[r][col]) moves.push({row: r, col});
                    else {
                        if ((piece === '♕' && isBlackPiece(boardState[r][col])) || 
                            (piece === '♛' && isWhitePiece(boardState[r][col]))) {
                            moves.push({row: r, col, capture: true});
                        }
                        break;
                    }
                }
                for (let c = col-1; c >= 0; c--) {
                    if (!boardState[row][c]) moves.push({row, col: c});
                    else {
                        if ((piece === '♕' && isBlackPiece(boardState[row][c])) || 
                            (piece === '♛' && isWhitePiece(boardState[row][c]))) {
                            moves.push({row, col: c, capture: true});
                        }
                        break;
                    }
                }
                for (let c = col+1; c < 8; c++) {
                    if (!boardState[row][c]) moves.push({row, col: c});
                    else {
                        if ((piece === '♕' && isBlackPiece(boardState[row][c])) || 
                            (piece === '♛' && isWhitePiece(boardState[row][c]))) {
                            moves.push({row, col: c, capture: true});
                        }
                        break;
                    }
                }
                
                // Movimentos de bispo
                for (let r = row-1, c = col-1; r >= 0 && c >= 0; r--, c--) {
                    if (!boardState[r][c]) moves.push({row: r, col: c});
                    else {
                        if ((piece === '♕' && isBlackPiece(boardState[r][c])) || 
                            (piece === '♛' && isWhitePiece(boardState[r][c]))) {
                            moves.push({row: r, col: c, capture: true});
                        }
                        break;
                    }
                }
                for (let r = row-1, c = col+1; r >= 0 && c < 8; r--, c++) {
                    if (!boardState[r][c]) moves.push({row: r, col: c});
                    else {
                        if ((piece === '♕' && isBlackPiece(boardState[r][c])) || 
                            (piece === '♛' && isWhitePiece(boardState[r][c]))) {
                            moves.push({row: r, col: c, capture: true});
                        }
                        break;
                    }
                }
                for (let r = row+1, c = col-1; r < 8 && c >= 0; r++, c--) {
                    if (!boardState[r][c]) moves.push({row: r, col: c});
                    else {
                        if ((piece === '♕' && isBlackPiece(boardState[r][c])) || 
                            (piece === '♛' && isWhitePiece(boardState[r][c]))) {
                            moves.push({row: r, col: c, capture: true});
                        }
                        break;
                    }
                }
                for (let r = row+1, c = col+1; r < 8 && c < 8; r++, c++) {
                    if (!boardState[r][c]) moves.push({row: r, col: c});
                    else {
                        if ((piece === '♕' && isBlackPiece(boardState[r][c])) || 
                            (piece === '♛' && isWhitePiece(boardState[r][c]))) {
                            moves.push({row: r, col: c, capture: true});
                        }
                        break;
                    }
                }
            }
            // Rei (1 casa em qualquer direção)
            else if (piece === '♔' || piece === '♚') {
                const kingMoves = [
                    {row: row-1, col: col-1}, {row: row-1, col: col}, {row: row-1, col: col+1},
                    {row: row, col: col-1}, {row: row, col: col+1},
                    {row: row+1, col: col-1}, {row: row+1, col: col}, {row: row+1, col: col+1}
                ];
                
                for (const move of kingMoves) {
                    if (move.row >= 0 && move.row < 8 && move.col >= 0 && move.col < 8) {
                        if (!boardState[move.row][move.col] || 
                            (piece === '♔' && isBlackPiece(boardState[move.row][move.col])) || 
                            (piece === '♚' && isWhitePiece(boardState[move.row][move.col]))) {
                            moves.push({
                                row: move.row, 
                                col: move.col, 
                                capture: !!boardState[move.row][move.col]
                            });
                        }
                    }
                }
            }
            
            return moves;
        }
        
        // IA faz um movimento
        async function makeAIMove() {
            addToChat("ChessBot: Pensando no meu movimento...", 'ai');
            
            try {
                // Simula um movimento aleatório (em uma implementação real, usaria a API)
                const blackPieces = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (boardState[row][col] && isBlackPiece(boardState[row][col])) {
                            blackPieces.push({row, col});
                        }
                    }
                }
                
                if (blackPieces.length > 0) {
                    const randomPiece = blackPieces[Math.floor(Math.random() * blackPieces.length)];
                    const moves = calculatePossibleMoves(randomPiece.row, randomPiece.col);
                    
                    if (moves.length > 0) {
                        const randomMove = moves[Math.floor(Math.random() * moves.length)];
                        movePiece(randomPiece.row, randomPiece.col, randomMove.row, randomMove.col);
                        renderBoard();
                        checkGameStatus();
                        addToChat(`ChessBot: Mova minha peça de ${String.fromCharCode(97 + randomPiece.col)}${8 - randomPiece.row} para ${String.fromCharCode(97 + randomMove.col)}${8 - randomMove.row}`, 'ai');
                    } else {
                        addToChat("ChessBot: Não tenho movimentos válidos!", 'ai');
                    }
                }
            } catch (error) {
                console.error("Erro na IA:", error);
                addToChat("ChessBot: Ocorreu um erro ao pensar no movimento", 'ai');
            }
        }
        
        // Move uma peça
        function movePiece(fromRow, fromCol, toRow, toCol, specialMove) {
            const fromNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}`;
            const toNotation = `${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            
            // Salva o estado para desfazer
            moveStack.push({
                board: JSON.parse(JSON.stringify(boardState)),
                currentPlayer,
                move: `${fromNotation} → ${toNotation}`,
                captured: boardState[toRow][toCol]
            });
            
            // Registra o movimento no histórico
            gameHistory.push({
                move: `${fromNotation} → ${toNotation}`,
                piece: boardState[fromRow][fromCol],
                captured: boardState[toRow][toCol],
                special: specialMove
            });
            
            // Executa o movimento
            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = null;
            
            // Promoção de peão (simplificada)
            if ((boardState[toRow][toCol] === '♙' && toRow === 0) || 
                (boardState[toRow][toCol] === '♟' && toRow === 7)) {
                boardState[toRow][toCol] = currentPlayer === 'white' ? '♕' : '♛';
                addToChat(`ChessBot: Peão promovido a rainha!`, 'ai');
            }
            
            // Troca o jogador
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            gameStatus.textContent = `Jogo em andamento - ${currentPlayer === 'white' ? 'Brancas' : 'Pretas'} jogam`;
        }
        
        // Desfaz o último movimento
        function undoMove() {
            if (moveStack.length > 0) {
                const lastState = moveStack.pop();
                boardState = lastState.board;
                currentPlayer = lastState.currentPlayer;
                gameHistory.pop();
                gameStatus.textContent = `Jogo em andamento - ${currentPlayer === 'white' ? 'Brancas' : 'Pretas'} jogam`;
                renderBoard();
                addToChat(`ChessBot: Movimento desfeito (${lastState.move})`, 'ai');
            } else {
                addToChat("ChessBot: Nenhum movimento para desfazer", 'ai');
            }
        }
        
        // Verifica o status do jogo
        function checkGameStatus() {
            let whiteKingFound = false;
            let blackKingFound = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === '♔') whiteKingFound = true;
                    if (boardState[row][col] === '♚') blackKingFound = true;
                }
            }
            
            if (!whiteKingFound) {
                gameStatus.textContent = "Xeque-mate! Pretas vencem!";
                addToChat("ChessBot: Xeque-mate! As pretas venceram. Parabéns!", 'ai');
            } else if (!blackKingFound) {
                gameStatus.textContent = "Xeque-mate! Brancas vencem!";
                addToChat("ChessBot: Xeque-mate! As brancas venceram. Parabéns!", 'ai');
            }
        }
        
        // Envia mensagem para o ChessBot
        async function sendToChessBot(message) {
            addToChat("Você: " + message, "user");
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "mistral-tiny",
                        messages: [
                            {
                                role: "system",
                                content: `Você é o ChessBot, um assistente especialista em xadrez. Responda de forma clara e didática, 
                                ajudando o usuário a melhorar seu jogo. Seja conciso mas informativo. Use termos de xadrez como 
                                'abertura', 'meio-jogo', 'final', 'tática', 'estratégia' conforme apropriado.`
                            },
                            {
                                role: "user",
                                content: message
                            }
                        ]
                    })
                });
                
                const data = await response.json();
                const aiResponse = data.choices[0].message.content;
                addToChat("ChessBot: " + aiResponse, "ai");
            } catch (error) {
                console.error("Erro ao chamar API:", error);
                addToChat("ChessBot: Desculpe, ocorreu um erro ao processar sua solicitação.", "ai");
            }
        }
        
        // Adiciona mensagem ao chat
        function addToChat(message, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = message;
            messageDiv.className = sender === 'user' ? 'user-msg' : 'chessbot-msg';
            messageDiv.style.marginBottom = '8px';
            chatOutput.appendChild(messageDiv);
            chatOutput.scrollTop = chatOutput.scrollHeight;
        }
        
        // Event Listeners
        sendBtn.addEventListener('click', () => {
            const message = userInput.value.trim();
            if (message) {
                sendToChessBot(message);
                userInput.value = '';
            }
        });
        
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const message = userInput.value.trim();
                if (message) {
                    sendToChessBot(message);
                    userInput.value = '';
                }
            }
        });
        
        hintBtn.addEventListener('click', () => {
            sendToChessBot(`Me dê uma dica para minha próxima jogada. Eu estou jogando com as ${currentPlayer === 'white' ? 'brancas' : 'pretas'}. 
                          O tabuleiro atual está na posição padrão.`);
        });
        
        tacticsBtn.addEventListener('click', () => {
            sendToChessBot("Explique algumas táticas importantes no xadrez, como garfo, espeto, descoberto e ataque duplo. Dê exemplos práticos com notação algébrica e quando aplicá-las.");
        });
        
        strategyBtn.addEventListener('click', () => {
            sendToChessBot("Fale sobre estratégias gerais no xadrez, como controle do centro, desenvolvimento de peças, estrutura de peões e vantagem de espaço. Organize por fase do jogo (abertura, meio-jogo, final).");
        });
        
        fullLessonBtn.addEventListener('click', () => {
            sendToChessBot(`Por favor, dê uma aula completa de xadrez cobrindo:
1. Aberturas: princípios básicos e exemplos das principais aberturas
2. Meio-jogo: estratégias e planos típicos, como ataque no flanco de rei
3. Finais: conceitos fundamentais e técnicas básicas
4. Análise de partidas: como aprender com jogos famosos
Seja detalhado mas mantenha uma linguagem acessível para iniciantes.`);
        });
        
        lessonBtn.addEventListener('click', () => {
            sendToChessBot("Dê uma aula rápida de 2-3 minutos sobre um conceito importante de xadrez que seja adequado para meu nível atual. Inclua um exemplo prático com notação algébrica.");
        });
        
        undoBtn.addEventListener('click', undoMove);
        
        resetBtn.addEventListener('click', () => {
            boardState = initializeBoard();
            currentPlayer = 'white';
            selectedPiece = null;
            possibleMoves = [];
            gameHistory = [];
            moveStack = [];
            gameStatus.textContent = "Jogo reiniciado - Brancas jogam";
            renderBoard();
            addToChat("ChessBot: Jogo reiniciado. Boa sorte! Diga-me como posso ajudar com seu treino de xadrez hoje.", "ai");
        });
        
        // Inicializa o jogo
        renderBoard();
        addToChat("ChessBot: Olá! Eu sou o ChessBot, seu assistente de xadrez inteligente. Você joga com as brancas e eu responderei com as pretas.", "ai");
        addToChat("ChessBot: Posso te ajudar com:", "ai");
        addToChat("- Dicas durante o jogo\n- Explicações sobre táticas\n- Estratégias para melhorar\n- Aulas completas\n- Análise de seus movimentos", "ai");
        addToChat("Faça seu primeiro movimento com as brancas!", "ai");
    </script>
</body>
</html>
