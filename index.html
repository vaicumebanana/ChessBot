<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChessBot - Assistente de Xadrez Inteligente</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            margin: 0 auto;
            border: 2px solid #333;
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
        }
        .white {
            background-color: #f0d9b5;
        }
        .black {
            background-color: #b58863;
        }
        .selected {
            background-color: rgba(0, 255, 0, 0.5);
        }
        .possible-move {
            background-color: rgba(0, 0, 255, 0.3);
        }
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        .chat-container {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background-color: white;
        }
        #chat-output {
            height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        #user-input {
            width: 70%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #send-btn {
            width: 25%;
        }
        .status {
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
        }
        .tactics-btn {
            background-color: #2196F3;
        }
        .strategy-btn {
            background-color: #ff9800;
        }
        .full-lesson-btn {
            background-color: #9c27b0;
        }
        .chessbot-msg {
            color: #2e7d32;
            font-weight: bold;
        }
        .user-msg {
            color: #1565c0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>ChessBot - Assistente de Xadrez Inteligente</h1>
    <div class="container">
        <div class="status" id="game-status">Jogo iniciado - Brancas jogam</div>
        <div class="chess-board" id="chess-board"></div>
        <div class="controls">
            <button id="hint-btn">Pedir Dica</button>
            <button id="tactics-btn" class="tactics-btn">Tática</button>
            <button id="strategy-btn" class="strategy-btn">Estratégia</button>
            <button id="full-lesson-btn" class="full-lesson-btn">Aula Completa</button>
            <button id="lesson-btn">Aula Rápida</button>
            <button id="reset-btn">Reiniciar Jogo</button>
        </div>
        <div class="chat-container">
            <div id="chat-output"></div>
            <input type="text" id="user-input" placeholder="Digite sua mensagem...">
            <button id="send-btn">Enviar</button>
        </div>
    </div>

    <script>
        // Configurações iniciais
        const apiKey = "5XY8QqPYtaJKjL1bZZSR6M8quXETRluO";
        const apiUrl = "https://api.mistral.ai/v1/chat/completions";
        
        // Estado do jogo
        let boardState = initializeBoard();
        let currentPlayer = 'white';
        let selectedPiece = null;
        let possibleMoves = [];
        let gameHistory = [];
        
        // Elementos do DOM
        const chessBoard = document.getElementById('chess-board');
        const gameStatus = document.getElementById('game-status');
        const chatOutput = document.getElementById('chat-output');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const hintBtn = document.getElementById('hint-btn');
        const tacticsBtn = document.getElementById('tactics-btn');
        const strategyBtn = document.getElementById('strategy-btn');
        const fullLessonBtn = document.getElementById('full-lesson-btn');
        const lessonBtn = document.getElementById('lesson-btn');
        const resetBtn = document.getElementById('reset-btn');
        
        // Inicializa o tabuleiro
        function initializeBoard() {
            // Cria um tabuleiro vazio 8x8
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            // Peças brancas
            board[0][0] = '♜'; board[0][1] = '♞'; board[0][2] = '♝'; board[0][3] = '♛';
            board[0][4] = '♚'; board[0][5] = '♝'; board[0][6] = '♞'; board[0][7] = '♜';
            for (let i = 0; i < 8; i++) board[1][i] = '♟';
            
            // Peças pretas
            board[7][0] = '♖'; board[7][1] = '♘'; board[7][2] = '♗'; board[7][3] = '♕';
            board[7][4] = '♔'; board[7][5] = '♗'; board[7][6] = '♘'; board[7][7] = '♖';
            for (let i = 0; i < 8; i++) board[6][i] = '♙';
            
            return board;
        }
        
        // Renderiza o tabuleiro
        function renderBoard() {
            chessBoard.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Marca peça selecionada
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // Marca movimentos possíveis
                    if (possibleMoves.some(move => move.row === row && move.col === col)) {
                        square.classList.add('possible-move');
                    }
                    
                    // Adiciona a peça se existir
                    if (boardState[row][col]) {
                        square.textContent = boardState[row][col];
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessBoard.appendChild(square);
                }
            }
        }
        
        // Manipula clique no quadrado
        function handleSquareClick(row, col) {
            const piece = boardState[row][col];
            
            // Se não há peça selecionada e o quadrado tem uma peça do jogador atual
            if (!selectedPiece && piece && ((currentPlayer === 'white' && isWhitePiece(piece)) || 
                                          (currentPlayer === 'black' && isBlackPiece(piece)))) {
                selectedPiece = { row, col };
                possibleMoves = calculatePossibleMoves(row, col);
                renderBoard();
            } 
            // Se há peça selecionada e clicou nela novamente, desseleciona
            else if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                selectedPiece = null;
                possibleMoves = [];
                renderBoard();
            } 
            // Se há peça selecionada e clicou em um movimento possível
            else if (selectedPiece && possibleMoves.some(move => move.row === row && move.col === col)) {
                movePiece(selectedPiece.row, selectedPiece.col, row, col);
                selectedPiece = null;
                possibleMoves = [];
                renderBoard();
                checkGameStatus();
            }
        }
        
        // Verifica se a peça é branca
        function isWhitePiece(piece) {
            return ['♙', '♖', '♘', '♗', '♕', '♔'].includes(piece);
        }
        
        // Verifica se a peça é preta
        function isBlackPiece(piece) {
            return ['♟', '♜', '♞', '♝', '♛', '♚'].includes(piece);
        }
        
        // Calcula movimentos possíveis (simplificado)
        function calculatePossibleMoves(row, col) {
            const piece = boardState[row][col];
            const moves = [];
            
            // Movimentos simplificados para exemplo
            if (piece === '♙') { // Peão branco
                if (row < 7 && !boardState[row+1][col]) moves.push({row: row+1, col});
                if (row === 1 && !boardState[row+1][col] && !boardState[row+2][col]) moves.push({row: row+2, col});
                // Capturas
                if (row < 7 && col > 0 && boardState[row+1][col-1] && isBlackPiece(boardState[row+1][col-1])) 
                    moves.push({row: row+1, col: col-1});
                if (row < 7 && col < 7 && boardState[row+1][col+1] && isBlackPiece(boardState[row+1][col+1])) 
                    moves.push({row: row+1, col: col+1});
            } 
            else if (piece === '♟') { // Peão preto
                if (row > 0 && !boardState[row-1][col]) moves.push({row: row-1, col});
                if (row === 6 && !boardState[row-1][col] && !boardState[row-2][col]) moves.push({row: row-2, col});
                // Capturas
                if (row > 0 && col > 0 && boardState[row-1][col-1] && isWhitePiece(boardState[row-1][col-1])) 
                    moves.push({row: row-1, col: col-1});
                if (row > 0 && col < 7 && boardState[row-1][col+1] && isWhitePiece(boardState[row-1][col+1])) 
                    moves.push({row: row-1, col: col+1});
            }
            // Torre (movimentos horizontais/verticais)
            else if (piece === '♖' || piece === '♜') {
                // Movimentos para cima
                for (let r = row-1; r >= 0; r--) {
                    if (!boardState[r][col]) moves.push({row: r, col});
                    else {
                        if ((piece === '♖' && isBlackPiece(boardState[r][col])) || 
                            (piece === '♜' && isWhitePiece(boardState[r][col]))) {
                            moves.push({row: r, col});
                        }
                        break;
                    }
                }
                // Movimentos para baixo
                for (let r = row+1; r < 8; r++) {
                    if (!boardState[r][col]) moves.push({row: r, col});
                    else {
                        if ((piece === '♖' && isBlackPiece(boardState[r][col])) || 
                            (piece === '♜' && isWhitePiece(boardState[r][col]))) {
                            moves.push({row: r, col});
                        }
                        break;
                    }
                }
                // Movimentos para esquerda
                for (let c = col-1; c >= 0; c--) {
                    if (!boardState[row][c]) moves.push({row, col: c});
                    else {
                        if ((piece === '♖' && isBlackPiece(boardState[row][c])) || 
                            (piece === '♜' && isWhitePiece(boardState[row][c]))) {
                            moves.push({row, col: c});
                        }
                        break;
                    }
                }
                // Movimentos para direita
                for (let c = col+1; c < 8; c++) {
                    if (!boardState[row][c]) moves.push({row, col: c});
                    else {
                        if ((piece === '♖' && isBlackPiece(boardState[row][c])) || 
                            (piece === '♜' && isWhitePiece(boardState[row][c]))) {
                            moves.push({row, col: c});
                        }
                        break;
                    }
                }
            }
            // Cavalo (movimentos em L)
            else if (piece === '♘' || piece === '♞') {
                const knightMoves = [
                    {row: row-2, col: col-1}, {row: row-2, col: col+1},
                    {row: row-1, col: col-2}, {row: row-1, col: col+2},
                    {row: row+1, col: col-2}, {row: row+1, col: col+2},
                    {row: row+2, col: col-1}, {row: row+2, col: col+1}
                ];
                
                for (const move of knightMoves) {
                    if (move.row >= 0 && move.row < 8 && move.col >= 0 && move.col < 8) {
                        if (!boardState[move.row][move.col] || 
                            (piece === '♘' && isBlackPiece(boardState[move.row][move.col])) || 
                            (piece === '♞' && isWhitePiece(boardState[move.row][move.col]))) {
                            moves.push(move);
                        }
                    }
                }
            }
            
            return moves;
        }
        
        // Move uma peça
        function movePiece(fromRow, fromCol, toRow, toCol) {
            gameHistory.push({
                move: `${String.fromCharCode(97 + fromCol)}${8 - fromRow} -> ${String.fromCharCode(97 + toCol)}${8 - toRow}`,
                piece: boardState[fromRow][fromCol],
                captured: boardState[toRow][toCol]
            });
            
            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = null;
            
            // Troca o jogador
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            gameStatus.textContent = `Jogo em andamento - ${currentPlayer === 'white' ? 'Brancas' : 'Pretas'} jogam`;
        }
        
        // Verifica o status do jogo
        function checkGameStatus() {
            // Verificação simplificada - na implementação real seria mais complexo
            let whiteKingFound = false;
            let blackKingFound = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === '♔') whiteKingFound = true;
                    if (boardState[row][col] === '♚') blackKingFound = true;
                }
            }
            
            if (!whiteKingFound) {
                gameStatus.textContent = "Xeque-mate! Pretas vencem!";
            } else if (!blackKingFound) {
                gameStatus.textContent = "Xeque-mate! Brancas vencem!";
            }
        }
        
        // Envia mensagem para a API Mistral
        async function sendToChessBot(message) {
            addToChat("Você: " + message, "user");
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "mistral-tiny",
                        messages: [
                            {
                                role: "system",
                                content: "Você é o ChessBot, um assistente especialista em xadrez. Responda de forma clara e didática, ajudando o usuário a melhorar seu jogo. Seja conciso mas informativo. Use termos de xadrez como 'abertura', 'meio-jogo', 'final', 'tática', 'estratégia' conforme apropriado."
                            },
                            {
                                role: "user",
                                content: message
                            }
                        ]
                    })
                });
                
                const data = await response.json();
                const aiResponse = data.choices[0].message.content;
                addToChat("ChessBot: " + aiResponse, "ai");
            } catch (error) {
                console.error("Erro ao chamar API:", error);
                addToChat("ChessBot: Desculpe, ocorreu um erro ao processar sua solicitação.", "ai");
            }
        }
        
        // Adiciona mensagem ao chat
        function addToChat(message, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = message;
            messageDiv.className = sender === 'user' ? 'user-msg' : 'chessbot-msg';
            messageDiv.style.marginBottom = '5px';
            chatOutput.appendChild(messageDiv);
            chatOutput.scrollTop = chatOutput.scrollHeight;
        }
        
        // Event Listeners
        sendBtn.addEventListener('click', () => {
            const message = userInput.value.trim();
            if (message) {
                sendToChessBot(message);
                userInput.value = '';
            }
        });
        
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const message = userInput.value.trim();
                if (message) {
                    sendToChessBot(message);
                    userInput.value = '';
                }
            }
        });
        
        hintBtn.addEventListener('click', () => {
            sendToChessBot(`Me dê uma dica para minha próxima jogada. Eu estou jogando com as ${currentPlayer === 'white' ? 'brancas' : 'pretas'}.`);
        });
        
        tacticsBtn.addEventListener('click', () => {
            sendToChessBot("Explique algumas táticas importantes no xadrez, como garfo, espeto, descoberto e ataque duplo. Dê exemplos práticos com notação algébrica.");
        });
        
        strategyBtn.addEventListener('click', () => {
            sendToChessBot("Fale sobre estratégias gerais no xadrez, como controle do centro, desenvolvimento de peças, estrutura de peões e vantagem de espaço. Organize por tópicos.");
        });
        
        fullLessonBtn.addEventListener('click', () => {
            sendToChessBot(`Por favor, dê uma aula completa de xadrez cobrindo:
1. Aberturas: princípios básicos e exemplos das principais aberturas
2. Meio-jogo: estratégias e planos típicos
3. Finais: conceitos fundamentais e técnicas
4. Análise de partidas: como aprender com jogos famosos
Seja detalhado mas mantenha uma linguagem acessível.`);
        });
        
        lessonBtn.addEventListener('click', () => {
            sendToChessBot("Dê uma aula rápida de 2-3 minutos sobre um conceito importante de xadrez que seja adequado para meu nível atual. Inclua um exemplo prático.");
        });
        
        resetBtn.addEventListener('click', () => {
            boardState = initializeBoard();
            currentPlayer = 'white';
            selectedPiece = null;
            possibleMoves = [];
            gameHistory = [];
            gameStatus.textContent = "Jogo reiniciado - Brancas jogam";
            renderBoard();
            addToChat("ChessBot: Jogo reiniciado. Boa sorte! Diga-me como posso ajudar com seu treino de xadrez hoje.", "ai");
        });
        
        // Inicializa o jogo
        renderBoard();
        addToChat("ChessBot: Olá! Eu sou o ChessBot, seu assistente de xadrez inteligente. Posso te ajudar com:", "ai");
        addToChat("ChessBot: - Dicas durante o jogo\n- Explicações sobre táticas\n- Estratégias para melhorar\n- Aulas completas sobre todos os aspectos do xadrez\nComo posso ajudar você hoje?", "ai");
    </script>
</body>
</html>
